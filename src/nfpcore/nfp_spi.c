/*
 *
 * Copyright 2015 Netronome Systems, Inc.
 *
 * This software is dual licensed under the GNU General  License Version 2,
 * June 1991 or the BSD 2-Clause License. The license template for each is
 * shown below:
 *
 * **************************************
 * GNU GENERAL PUBLIC LICENSE
 *
 * Version 2, June 1991
 * Copyright (C) 1989, 1991 Free Software Foundation, Inc.
 * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
 *
 * Everyone is permitted to copy and distribute verbatim copies of this
 * license document, but changing it is not allowed.
 *
 * Preamble
 *
 * The licenses for most software are designed to take away your freedom to
 * share and change it. By contrast, the GNU General Public License is
 * intended to guarantee your freedom to share and change free software--to
 * make sure the software is free for all its users. This General Public
 * License applies to most of the Free Software Foundation's software and to
 * any other program whose authors commit to using it. (Some other Free
 * Software Foundation software is covered by the GNU Lesser General Public
 * License instead.) You can apply it to your programs, too.
 *
 * When we speak of free software, we are referring to freedom, not price. Our
 * General Public Licenses are designed to make sure that you have the freedom
 * to distribute copies of free software (and charge for this service if you
 * wish), that you receive source code or can get it if you want it, that you
 * can change the software or use pieces of it in new free programs; and that
 * you know you can do these things.
 *
 * To protect your rights, we need to make restrictions that forbid anyone to
 * deny you these rights or to ask you to surrender the rights. These
 * restrictions translate to certain responsibilities for you if you distribute
 * copies of the software, or if you modify it.
 *
 * For example, if you distribute copies of such a program, whether gratis or
 * for a fee, you must give the recipients all the rights that you have. You
 * must make sure that they, too, receive or can get the source code. And you
 * must show them these terms so they know their rights.
 *
 * We protect your rights with two steps: (1) copyright the software, and (2)
 * offer you this license which gives you legal permission to copy, distribute
 * and/or modify the software.
 *
 * Also, for each author's protection and ours, we want to make certain that
 * everyone understands that there is no warranty for this free software. If
 * the software is modified by someone else and passed on, we want its
 * recipients to know that what they have is not the original, so that any
 * problems introduced by others will not reflect on the original authors'
 * reputations.
 *
 * Finally, any free program is threatened constantly by software patents. We
 * wish to avoid the danger that redistributors of a free program will
 * individually obtain patent licenses, in effect making the program
 * proprietary. To prevent this, we have made it clear that any patent
 * must be licensed for everyone's free use or not licensed at all.
 *
 * The precise terms and conditions for copying, distribution and modification
 * follow.
 *
 * TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
 *
 * 0. This License applies to any program or other work which contains a
 * notice placed by the copyright holder saying it may be distributed under the
 * terms of this General Public License. The "Program", below, refers to any
 * such program or work, and a "work based on the Program" means either the
 * Program or any derivative work under copyright law: that is to say, a work
 * containing the Program or a portion of it, either verbatim or with
 * modifications and/or translated into another language. (Hereinafter,
 * translation is included without limitation in the term "modification".)
 * Each licensee is addressed as "you".
 *
 * Activities other than copying, distribution and modification are not covered
 * by this License; they are outside its scope. The act of running the Program
 * is not restricted, and the output from the Program is covered only if its
 * contents constitute a work based on the Program (independent of having been
 * made by running the Program). Whether that is true depends on what the
 * Program does.
 *
 * 1. You may copy and distribute verbatim copies of the Program's source code
 * as you receive it, in any medium, provided that you conspicuously and
 * appropriately publish on each copy an appropriate copyright notice and
 * disclaimer of warranty; keep intact all the notices that refer to this
 * License and to the absence of any warranty; and give any other recipients of
 * the Program a copy of this License along with the Program.
 *
 * You may charge a fee for the physical act of transferring a copy, and you
 * may at your option offer warranty protection in exchange for a fee.
 *
 * 2. You may modify your copy or copies of the Program or any portion of it,
 * thus forming a work based on the Program, and copy and distribute such
 * modifications or work under the terms of Section 1 above, provided that you
 * also meet all of these conditions:
 *
 *
 * a) You must cause the modified files to carry prominent notices stating that
 * you changed the files and the date of any change.
 *
 * b) You must cause any work that you distribute or publish, that in whole or
 * in part contains or is derived from the Program or any part thereof, to be
 * licensed as a whole at no charge to all third parties under the terms of
 * this License.
 *
 * c) If the modified program normally reads commands interactively when run,
 * you must cause it, when started running for such interactive use in the most
 * ordinary way, to print or display an announcement including an appropriate
 * copyright notice and a notice that there is no warranty (or else, saying
 * that you provide a warranty) and that users may redistribute the program
 * under these conditions, and telling the user how to view a copy of this
 * License. (Exception: if the Program itself is interactive but does not
 * normally print such an announcement, your work based on the Program is not
 * required to print an announcement.)
 *
 * These requirements apply to the modified work as a whole. If identifiable
 * sections of that work are not derived from the Program, and can be
 * reasonably considered independent and separate works in themselves, then
 * this License, and its terms, do not apply to those sections when you
 * distribute them as separate works. But when you distribute the same sections
 * as part of a whole which is a work based on the Program, the distribution of
 * the whole must be on the terms of this License, whose permissions for other
 * licensees extend to the entire whole, and thus to each and every part
 * regardless of who wrote it.
 *
 * Thus, it is not the intent of this section to claim rights or contest your
 * rights to work written entirely by you; rather, the intent is to exercise
 * the right to control the distribution of derivative or collective works
 * based on the Program.
 *
 * In addition, mere aggregation of another work not based on the Program with
 * the Program (or with a work based on the Program) on a volume of a storage
 * or distribution medium does not bring the other work under the scope of
 * this License.
 *
 * 3. You may copy and distribute the Program (or a work based on it, under
 * Section 2) in object code or executable form under the terms of Sections
 * 1 and 2 above provided that you also do one of the following:
 *
 * a) Accompany it with the complete corresponding machine-readable source
 * code, which must be distributed under the terms of Sections 1 and 2 above
 * on a medium customarily used for software interchange; or,
 *
 * b) Accompany it with a written offer, valid for at least three years, to
 * give any third party, for a charge no more than your cost of physically
 * performing source distribution, a complete machine-readable copy of the
 * corresponding source code, to be distributed under the terms of Sections 1
 * and 2 above on a medium customarily used for software interchange; or,
 *
 * c) Accompany it with the information you received as to the offer to
 * distribute corresponding source code. (This alternative is allowed only
 * for noncommercial distribution and only if you received the program in
 * object code or executable form with such an offer, in accord with Subsection
 * b above.)
 *
 * The source code for a work means the preferred form of the work for making
 * modifications to it. For an executable work, complete source code means all
 * the source code for all modules it contains, plus any associated interface
 * definition files, plus the scripts used to control compilation and
 * installation of the executable. However, as a special exception, the source
 * code distributed need not include anything that is normally distributed
 * (in either source or binary form) with the major components (compiler,
 * kernel, and so on) of the operating system on which the executable runs,
 * unless that component itself accompanies the executable.
 *
 * If distribution of executable or object code is made by offering access to
 * copy from a designated place, then offering equivalent access to copy the
 * source code from the same place counts as distribution of the source code,
 * even though third parties are not compelled to copy the source along with
 * the object code.
 *
 * 4. You may not copy, modify, sublicense, or distribute the Program except
 * as expressly provided under this License. Any attempt otherwise to copy,
 * modify, sublicense or distribute the Program is void, and will automatically
 * terminate your rights under this License. However, parties who have received
 * copies, or rights, from you under this License will not have their licenses
 * terminated so long as such parties remain in full compliance.
 *
 * 5. You are not required to accept this License, since you have not signed
 * it. However, nothing else grants you permission to modify or distribute the
 * Program or its derivative works. These actions are prohibited by law if you
 * do not accept this License. Therefore, by modifying or distributing the
 * Program (or any work based on the Program), you indicate your acceptance of
 * this License to do so, and all its terms and conditions for copying,
 * distributing or modifying the Program or works based on it.
 *
 * 6. Each time you redistribute the Program (or any work based on the
 * Program), the recipient automatically receives a license from the original
 * licensor to copy, distribute or modify the Program subject to these terms
 * and conditions. You may not impose any further restrictions on the
 * recipients' exercise of the rights granted herein. You are not responsible
 * for enforcing compliance by third parties to this License.
 *
 * 7. If, as a consequence of a court judgment or allegation of patent
 * infringement or for any other reason (not limited to patent issues),
 * conditions are imposed on you (whether by court order, agreement or
 * otherwise) that contradict the conditions of this License, they do not
 * excuse you from the conditions of this License. If you cannot distribute so
 * as to satisfy simultaneously your obligations under this License and any
 * other pertinent obligations, then as a consequence you may not distribute
 * the Program at all. For example, if a patent license would not permit
 * royalty-free redistribution of the Program by all those who receive copies
 * directly or indirectly through you, then the only way you could satisfy both
 * it and this License would be to refrain entirely from distribution of the
 * Program.
 *
 * If any portion of this section is held invalid or unenforceable under any
 * particular circumstance, the balance of the section is intended to apply and
 * the section as a whole is intended to apply in other circumstances.
 *
 * It is not the purpose of this section to induce you to infringe any patents
 * or other property right claims or to contest validity of any such claims;
 * this section has the sole purpose of protecting the integrity of the free
 * software distribution system, which is implemented by public license
 * practices. Many people have made generous contributions to the wide range
 * of software distributed through that system in reliance on consistent
 * application of that system; it is up to the author/donor to decide if he or
 * she is willing to distribute software through any other system and a
 * licensee cannot impose that choice.
 *
 * This section is intended to make thoroughly clear what is believed to be a
 * consequence of the rest of this License.
 *
 * 8. If the distribution and/or use of the Program is restricted in certain
 * countries either by patents or by copyrighted interfaces, the original
 * copyright holder who places the Program under this License may add an
 * explicit geographical distribution limitation excluding those countries, so
 * that distribution is permitted only in or among countries not thus excluded.
 * In such case, this License incorporates the limitation as if written in the
 * body of this License.
 *
 * 9. The Free Software Foundation may publish revised and/or new versions of
 * the General Public License from time to time. Such new versions will be
 * similar in spirit to the present version, but may differ in detail to
 * address new problems or concerns.
 *
 * Each version is given a distinguishing version number. If the Program
 * specifies a version number of this License which applies to it and "any
 * later version", you have the option of following the terms and conditions
 * either of that version or of any later version published by the Free
 * Software Foundation. If the Program does not specify a version number of
 * this License, you may choose any version ever published by the Free Software
 * Foundation.
 *
 * 10. If you wish to incorporate parts of the Program into other free programs
 * whose distribution conditions are different, write to the author to ask for
 * permission. For software which is copyrighted by the Free Software
 * Foundation, write to the Free Software Foundation; we sometimes make
 * exceptions for this. Our decision will be guided by the two goals of
 * preserving the free status of all derivatives of our free software and of
 * promoting the sharing and reuse of software generally.
 *
 * NO WARRANTY
 *
 * 11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
 * FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN
 * OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
 * PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
 * OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO
 * THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE PROGRAM
 * PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR
 * CORRECTION.
 *
 * 12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
 * WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
 * REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
 * INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
 * OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO
 * LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR
 * THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
 * PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGES.
 *
 * **************************************
 *
 * The BSD 2-Clause License:
 * Copyright 2015 Netronome Systems, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * nfp_spi.c
 */
#include <linux/kernel.h>
#include <linux/time.h>

#include "nfp.h"
#include "nfp_spi.h"

#include "nfp6000/nfp6000.h"

struct nfp_spi {
	struct nfp_cpp *cpp;
	struct nfp_cpp_area *csr;
	int mode;
	int clkdiv;
	int bus;
	int width;
	int key;
};

#define NFP_ARM_SPI                                          (0x403c00)

#define NFP_SPI_TIMEOUT_MS         100

/* NFP6000 SPI CONTROLLER defines */
#define NFP_SPI_PORTMC(x)    (0x10 + (((x) & 3) << 2))
#define   NFP_SPI_PORTMC_DATADRIVEDISABLE                 BIT(31)
#define   NFP_SPI_PORTMC_CLOCKIDLE                        BIT(29)
#define   NFP_SPI_PORTMC_SELECT(_x)                       (((_x) & 0xf) << 24)
#define   NFP_SPI_PORTMC_DATAWIDTH(_x)                    (((_x) & 0x3) << 20)
#define   NFP_SPI_PORTMC_DATAINTRAIL                      BIT(19)
#define   NFP_SPI_PORTMC_DATAINLEAD                       BIT(18)
#define   NFP_SPI_PORTMC_DATAOUTTRAIL                     BIT(17)
#define   NFP_SPI_PORTMC_DATAOUTLEAD                      BIT(16)
#define   NFP_SPI_PORTMC_CLOCKDISABLE                     BIT(15)
#define   NFP_SPI_PORTMC_CLOCKEDGECOUNT(_x)               (((_x) & 0x7f) << 8)
#define NFP_SPI_PORTCFG(x)   (0x00 + (((x) & 3) << 2))
#define   NFP_SPI_PORTCFG_MODE                            BIT(31)
#define     NFP_SPI_PORTCFG_MODE_AUTOMATIC                (0 << 31)
#define     NFP_SPI_PORTCFG_MODE_MANUAL                   BIT(31)
#define NFP_SPI_PORTMDO(x)   (0x20 + (((x) & 3) << 2))
#define NFP_SPI_PORTMDI(x)   (0x30 + (((x) & 3) << 2))
#define NFP_SPI_SPIIOCONFIG                                  0x00000100
#define NFP_SPI_SPIIOIDLESTATUS                              0x00000104
#define NFP_SPI_WE                         0x0000010c
#define   NFP_SPI_WE_AVAILABLE  BIT(4)
#define   NFP_SPI_WE_WRITEENABLETARGET(_x) (((_x) & 0xf) << 0)
#define   NFP_SPI_PORTCFG_BUSY                            BIT(30)

#define VALID_CS(cs)            ((cs >= 0) && (cs <= 3))
#define CS_OFF                  NFP_SPI_PORTMC_SELECT(0xf)
#define CS_BITS(cs)                                       \
		((VALID_CS(cs)) ?                         \
		NFP_SPI_PORTMC_SELECT((0xf & ~(1 << cs))) \
		: CS_OFF)

#define SPIMODEBITS(s)                                                \
	((s->mode & BIT(1) ? NFP_SPI_PORTMC_CLOCKIDLE : 0) |        \
	 (s->mode & BIT(0)                                          \
	  ? (NFP_SPI_PORTMC_DATAINTRAIL | NFP_SPI_PORTMC_DATAOUTLEAD) \
	  : (NFP_SPI_PORTMC_DATAINLEAD | NFP_SPI_PORTMC_DATAOUTTRAIL)))

#define CPHA(mode)  (mode & 1)

#define NFP6_SPI_DEFAULT_CTRL(edges, spi)          \
	(SPIMODEBITS(spi)                          \
	 | NFP_SPI_PORTMC_DATAWIDTH(spi->width)    \
	 | (spi)->clkdiv                           \
	 | NFP_SPI_PORTMC_CLOCKEDGECOUNT(edges))

#define SET_EDGE_COUNT(ctrl, cnt) \
	do {                                                    \
		ctrl &= ~0x7f00;                                \
		ctrl |= NFP_SPI_PORTMC_CLOCKEDGECOUNT(cnt);     \
	} while (0)

#define SPI_DEFAULT_MODE        (BIT(1) | BIT(0))	/* SPI_MODE3 */
#define SPIXDAT23_OFFS          8
#define SPI_MAX_BITS_PER_CTRL_WRITE 32

/* SPI source clock is PCLK(1GHz), the clock divider bits are
 * the count of PCLKs per SPI half-cycle, 8bits of divider give
 * a range 1-256 per half cycle or 2-512 per cycle, giving a
 * clock range of 500MHz down to ~2MHz
 *
 * pclk_freq(1000MHz) / (2 * (1 + pclk_half_cycle_count_bits)) = spi_freq
 */
#define MHZ(x)                  ((x) * 1000 * 1000)
#define PCLK_HZ                MHZ(1000)
#define MIN_SPI_HZ              ((PCLK_HZ / 512))	/*   ~2MHz */
#define MAX_SPI_HZ              ((PCLK_HZ /   2))	/* ~500MHz */
#define DEF_SPI_HZ              MHZ(5)

#define BITS_TO_BYTES(x)    (((x) + 7) / 8)

static int nfp6000_spi_csr_readl(struct nfp_spi *spi, u32 csr, u32 *val)
{
	return nfp_cpp_area_readl(spi->csr, csr, val);
}

static int nfp6000_spi_csr_writel(struct nfp_spi *spi, u32 csr, u32 val)
{
	return nfp_cpp_area_writel(spi->csr, csr, val);
}

/******************************************************************************/

#define offset_of(s, e)         ((intptr_t)&((s *)NULL)->e)

/******************************************************************************/

static int nfp6000_spi_run_clock(struct nfp_spi *spi, u32 control)
{
	u32 tmp;
	int err;
	struct timespec ts, timeout = {
		.tv_sec = NFP_SPI_TIMEOUT_MS / 1000,
		.tv_nsec = (NFP_SPI_TIMEOUT_MS % 1000) * 1000000,
	};

	err = nfp6000_spi_csr_writel(spi, NFP_SPI_PORTMC(spi->bus), control);
	if (err < 0)
		return err;

	ts = CURRENT_TIME;
	timeout = timespec_add(ts, timeout);

	for (ts = CURRENT_TIME;
	     timespec_compare(&ts, &timeout) < 0; ts = CURRENT_TIME) {
		err =
		    nfp6000_spi_csr_readl(spi, NFP_SPI_PORTCFG(spi->bus),
					  &tmp);
		if (err < 0)
			return err;

		if (!(tmp & NFP_SPI_PORTCFG_BUSY))
			return 0;
	}

	return -ETIMEDOUT;
}

static int nfp_spi_set_pin_association(struct nfp_spi *spi, int port, int pin)
{
	unsigned int val;
	int err;

	err = nfp6000_spi_csr_readl(spi, NFP_SPI_SPIIOCONFIG, &val);
	if (err < 0)
		return err;
	val &= ~(0x3 << (2 * ((pin & 3) - 1)));
	val |= (port & 3) << (2 * ((pin & 3) - 1));

	return nfp6000_spi_csr_writel(spi, NFP_SPI_SPIIOCONFIG, val);
}

static int do_first_bit_cpha0_hack(struct nfp_spi *spi, u32 ctrl,
				   u32 mdo)
{
	u32 control = ctrl | NFP_SPI_PORTMC_CLOCKDISABLE;

	SET_EDGE_COUNT(control, 1);

	return nfp6000_spi_run_clock(spi, control);
}

static int nfp6000_spi_cs_control(struct nfp_spi *spi, int cs, u32 enable)
{
	u32 ctrl = NFP6_SPI_DEFAULT_CTRL(4, spi) |
	    NFP_SPI_PORTMC_CLOCKDISABLE;

	ctrl |= (enable) ? CS_BITS(cs) : CS_OFF;

	return nfp6000_spi_run_clock(spi, ctrl);
}

static int nfp6000_spi_set_manual_mode(struct nfp_spi *spi)
{
	u32 tmp;
	int err;

	err = nfp6000_spi_csr_readl(spi, NFP_SPI_PORTCFG(spi->bus), &tmp);
	if (err < 0)
		return err;
	tmp |= NFP_SPI_PORTCFG_MODE_MANUAL;
	return nfp6000_spi_csr_writel(spi, NFP_SPI_PORTCFG(spi->bus), tmp);
}

#define SPI0_CLKIDLE_OFFS   0
#define SPI1_CLKIDLE_OFFS   4
#define SPI2_CLKIDLE_OFFS   8
#define SPI3_CLKIDLE_OFFS   10
static int nfp6000_spi_set_clk_pol(struct nfp_spi *spi)
{
	int err;
	unsigned int val;
	unsigned int polbit_offset[] = { SPI0_CLKIDLE_OFFS, SPI1_CLKIDLE_OFFS,
		SPI2_CLKIDLE_OFFS, SPI3_CLKIDLE_OFFS
	};
	err = nfp6000_spi_csr_readl(spi, NFP_SPI_SPIIOIDLESTATUS, &val);
	if (err < 0)
		return err;
	val &= ~(1 << (polbit_offset[spi->bus & 3]));
	val |= ((spi->mode & 1) << (polbit_offset[spi->bus & 3]));

	return nfp6000_spi_csr_writel(spi, NFP_SPI_SPIIOIDLESTATUS, val);
}

/**
 * nfp6000_spi_transact() - Perform an arbitrary SPI transaction
 * @spi:                      SPI Bus
 * @cs:                       SPI Chip select (0..3)
 * @cs_action:                Combination of the CS_SELECT and CS_DESELECT flags
 * @tx:                       TX buffer
 * @tx_bit_cnt:               TX buffer size in bits
 * @rx:                       RX buffer
 * @rx_bit_cnt:               RX buffer size in bits
 * @mdio_data_drive_disable:  MDIO compatibility flag
 *
 * Return: 0 or -ERRNO
 */
int nfp6000_spi_transact(struct nfp_spi *spi, int cs, int cs_action,
			 const void *tx, u32 tx_bit_cnt,
			 void *rx, u32 rx_bit_cnt,
			 int mdio_data_drive_disable)
{
	int err = 0;
	int first_tx_bit = 1;
	u32 i, tmp, ctrl, clk_bit_cnt;
	u8 *_tx, *_rx;
	u32 txbits, rxbits;

	ctrl = SPIMODEBITS(spi);
	ctrl |=
	    NFP_SPI_PORTMC_DATAWIDTH(spi->width) | spi->clkdiv | CS_BITS(cs);

	if (mdio_data_drive_disable && !tx) {
		/* used only for MDIO compatibility/implementation
		 * via this routine
		 */
		ctrl |= NFP_SPI_PORTMC_DATADRIVEDISABLE;
	}

	if (VALID_CS(cs) && (cs_action & CS_SELECT)) {
		if (cs > 0)
			nfp_spi_set_pin_association(spi, spi->bus, cs);
		err = nfp6000_spi_cs_control(spi, cs, 1);
		if (err < 0)
			return err;
	}

	_tx = (u8 *)tx;
	_rx = (u8 *)rx;
	while ((tx_bit_cnt > 0) || (rx_bit_cnt > 0)) {
		txbits =
		    min_t(u32, SPI_MAX_BITS_PER_CTRL_WRITE, tx_bit_cnt);
		rxbits =
		    min_t(u32, SPI_MAX_BITS_PER_CTRL_WRITE, rx_bit_cnt);
		clk_bit_cnt = max_t(u32, rxbits, txbits);
		if (clk_bit_cnt < SPI_MAX_BITS_PER_CTRL_WRITE)
			clk_bit_cnt = (clk_bit_cnt + 7) & ~7;

		SET_EDGE_COUNT(ctrl, 2 * clk_bit_cnt);

		if (txbits) {
			if (txbits % 8)
				_tx[txbits / 8] |=
				    ((1 << (8 - (txbits % 8))) - 1);
			for (i = 0, tmp = 0; i < BITS_TO_BYTES(txbits);
			     i++, _tx++)
				tmp |= (_tx[0] << (24 - (i * 8)));
			for (; i < BITS_TO_BYTES(SPI_MAX_BITS_PER_CTRL_WRITE);
			     i++, _tx++)
				tmp |= (0xff << (24 - (i * 8)));
		} else {
			tmp = 0xffffffff;
		}
		err =
		    nfp6000_spi_csr_writel(spi, NFP_SPI_PORTMDO(spi->bus),
					   tmp);
		if (err < 0)
			return err;

		if (first_tx_bit && CPHA(spi->mode) == 0) {
			do_first_bit_cpha0_hack(spi, ctrl, tmp);
			first_tx_bit = 0;
		}

		err = nfp6000_spi_run_clock(spi, ctrl);
		if (err < 0)
			return err;

		if (rxbits) {
			err =
			    nfp6000_spi_csr_readl(spi,
						  NFP_SPI_PORTMDI(spi->bus),
						  &tmp);
			if (err < 0)
				return err;
			if (clk_bit_cnt < SPI_MAX_BITS_PER_CTRL_WRITE)
				tmp =
				    tmp << (SPI_MAX_BITS_PER_CTRL_WRITE -
					    clk_bit_cnt);

			for (i = 0; i < BITS_TO_BYTES(rxbits); i++, _rx++)
				_rx[0] = (tmp >> (24 - (i * 8))) & 0xff;
		}
		tx_bit_cnt -= txbits;
		rx_bit_cnt -= rxbits;
	}

	if (VALID_CS(cs) && (cs_action & CS_DESELECT))
		err = nfp6000_spi_cs_control(spi, cs, 0);

	return err;
}

/**
 * nfp_spi_read() - Perform a trivial SPI read
 * @spi:     SPI Bus
 * @cs:      SPI Chip select (0..3)
 * @cmd_len: Number of bytes in the command
 * @cmd:     SPI command
 * @res_len: Number of bytes of response
 * @res:     SPI response
 *
 * Return: 0 or -ERRNO
 */
int nfp_spi_read(struct nfp_spi *spi, int cs,
		 unsigned int cmd_len, const void *cmd,
		 unsigned int res_len, void *res)
{
	int err;

	err = nfp6000_spi_transact(spi, cs, CS_SELECT,
				   cmd, cmd_len * 8, NULL, 0, 0);
	if (err < 0)
		return err;

	return nfp6000_spi_transact(spi, cs, CS_DESELECT,
				    NULL, 0, res, res_len * 8, 0);
}

/**
 * nfp_spi_write() - Perform a trivial SPI write
 * @spi:     SPI Bus
 * @cs:      SPI Chip select (0..3)
 * @cmd_len: Number of bytes in the command
 * @cmd:     SPI command
 * @dat_len: Number of bytes of write data
 * @dat:     SPI write data
 *
 * Return: 0 or -ERRNO
 */
int nfp_spi_write(struct nfp_spi *spi, int cs,
		  unsigned int cmd_len, const void *cmd,
		  unsigned int dat_len, const void *dat)
{
	int err;

	err = nfp6000_spi_transact(spi, cs, CS_SELECT,
				   cmd, cmd_len * 8, NULL, 0, 0);
	if (err < 0)
		return err;

	return nfp6000_spi_transact(spi, cs, CS_DESELECT,
				    dat, dat_len * 8, NULL, 0, 0);
}

static inline int spi_interface_key(uint16_t interface)
{
	switch (NFP_CPP_INTERFACE_TYPE_of(interface)) {
	case NFP_CPP_INTERFACE_TYPE_ARM:
		return 1;
	case NFP_CPP_INTERFACE_TYPE_PCI:
		return NFP_CPP_INTERFACE_UNIT_of(interface) + 2;
	default:
		return -EINVAL;
	}
}

/**
 * nfp_spi_acquire() - Acquire a handle to one of the NFP SPI busses
 * @nfp:     NFP Device
 * @bus:     SPI Bus (0..3)
 * @width:   SPI Bus Width (0 (default), 1 bit, 2 bit, or 4 bit)
 *
 * Return: NFP SPI handle or ERR_PTR()
 */
struct nfp_spi *nfp_spi_acquire(struct nfp_device *nfp, int bus, int width)
{
	struct nfp_spi *spi;
	struct nfp_cpp *cpp;
	int err, key;
	u32 val;
	int timeout = 5 * 1000;	/* 5s */

	if (width != 0 && width != 1 && width != 2 && width != 4)
		return ERR_PTR(-EINVAL);

	cpp = nfp_device_cpp(nfp);
	key = spi_interface_key(nfp_cpp_interface(cpp));
	if (key < 0)
		return ERR_PTR(key);

	spi = kzalloc(sizeof(*spi), GFP_KERNEL);
	if (!spi)
		return ERR_PTR(-ENOMEM);

	spi->cpp = cpp;
	spi->key = key;
	spi->mode = SPI_DEFAULT_MODE;
	spi->bus = bus;
	spi->width = (width == 0 || width == 1) ? 1 : (width == 2) ? 2 : 3;

	spi->csr = nfp_cpp_area_alloc_acquire(spi->cpp,
					      NFP_CPP_ID(NFP_CPP_TARGET_ARM,
							 NFP_CPP_ACTION_RW, 0),
					      NFP_ARM_SPI, 0x400);

	if (!spi->csr) {
		kfree(spi);
		return ERR_PTR(-ENOMEM);
	}

	/* Is it locked? */
	for (; timeout > 0; timeout -= 100) {
		nfp6000_spi_csr_writel(spi, NFP_SPI_WE,
				       spi->key);
		nfp6000_spi_csr_readl(spi, NFP_SPI_WE, &val);
		if (val == spi->key)
			break;
		if (msleep_interruptible(100) != 100) {
			nfp_cpp_area_release_free(spi->csr);
			kfree(spi);
			return ERR_PTR(-EINTR);
		}
	}

	/* Unable to claim the SPI device lock? */
	if (timeout <= 0) {
		nfp_cpp_area_release_free(spi->csr);
		kfree(spi);
		return ERR_PTR(-EBUSY);
	}

	/* DAT1(SPI MISO) is disabled(configured as SPI port 0 DAT2/3)
	 * by default for SPI ports 2 and 3
	 */
	if (bus > 1) {
		err = nfp6000_spi_csr_readl(spi, NFP_SPI_SPIIOCONFIG, &val);
		if (err < 0) {
			kfree(spi);
			return ERR_PTR(err);
		}
		val &= ~(3 << SPIXDAT23_OFFS);
		val |= ((bus & 3) << SPIXDAT23_OFFS);
		err = nfp6000_spi_csr_writel(spi, NFP_SPI_SPIIOCONFIG, val);
		if (err < 0) {
			nfp_cpp_area_release_free(spi->csr);
			kfree(spi);
			return ERR_PTR(err);
		}
	}

	nfp_spi_speed_set(spi, DEF_SPI_HZ);
	err = nfp6000_spi_set_manual_mode(spi);
	if (err < 0) {
		nfp_cpp_area_release_free(spi->csr);
		kfree(spi);
		return ERR_PTR(err);
	}

	nfp6000_spi_set_clk_pol(spi);
	return spi;
}

/**
 * nfp_spi_release() - Release the handle to a NFP SPI bus
 * @spi:     NFP SPI bus
 */
void nfp_spi_release(struct nfp_spi *spi)
{
	nfp6000_spi_csr_writel(spi, NFP_SPI_WE,
			       NFP_SPI_WE_AVAILABLE);
	nfp_cpp_area_release_free(spi->csr);
	kfree(spi);
}

/**
 * nfp_spi_speed_set() - Set the clock rate of the NFP SPI bus
 * @spi:     NFP SPI bus
 * @hz:      SPI clock rate (-1 = default speed)
 *
 * Return: 0 or -ERRNO
 */
int nfp_spi_speed_set(struct nfp_spi *spi, int hz)
{
	if (hz < 0)
		hz = DEF_SPI_HZ;

	if (hz < MIN_SPI_HZ || hz > MAX_SPI_HZ)
		return -EINVAL;

	/* clkdiv = PCLK_HZ / 2 / hz - 1 */
	spi->clkdiv = PCLK_HZ / 2 / hz - 1;

	return 0;
}

/**
 * nfp_spi_speed_get() - Get the clock rate of the NFP SPI bus
 * @spi:     NFP SPI bus
 * @hz:      SPI clock rate pointer
 *
 * Return: 0 or -ERRNO
 */
int nfp_spi_speed_get(struct nfp_spi *spi, int *hz)
{
	if (hz)
		*hz = PCLK_HZ / 2 / (spi->clkdiv + 1);

	return 0;
}

/**
 * nfp_spi_mode_set() - Set the SPI mode
 * @spi:     NFP SPI bus
 * @mode:    SPI CPHA/CPOL mode (-1, 0, 1, 2, or 3)
 *
 * Use mode of '-1' for the default for this bus.
 *
 * Return: 0 or -ERRNO
 */
int nfp_spi_mode_set(struct nfp_spi *spi, int mode)
{
	if (mode < -1 || mode > 3)
		return -EINVAL;

	spi->mode = (mode == -1) ? SPI_DEFAULT_MODE : mode;
	nfp6000_spi_set_clk_pol(spi);

	return 0;
}

/**
 * nfp_spi_mode_get() - Get the SPI mode
 * @spi:     NFP SPI bus
 * @mode:    SPI CPHA/CPOL mode pointer
 *
 * Return: 0 or -ERRNO
 */
int nfp_spi_mode_get(struct nfp_spi *spi, int *mode)
{
	if (mode)
		*mode = spi->mode;

	return 0;
}
